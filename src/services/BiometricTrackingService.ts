export interface BiometricData {
  id: string
  timestamp: number
  date: string
  heartRate?: number // bpm
  heartRateVariability?: number // RMSSD in ms
  stepCount?: number
  caloriesBurned?: number
  sleepDuration?: number // hours
  sleepQuality?: number // 0-100 score
  stressLevel?: number // 0-100, higher = more stressed
  energyLevel?: number // 0-100, higher = more energetic
  mood?: number // 0-100, higher = better mood
  focusLevel?: number // 0-100, self-reported
  hydrationLevel?: number // ml of water consumed
  screenTime?: number // hours
  physicalActivity?: {
    type: string
    duration: number // minutes
    intensity: 'low' | 'moderate' | 'high'
  }[]
  location?: {
    latitude: number
    longitude: number
    address?: string
  }
  weather?: {
    temperature: number
    humidity: number
    condition: string
  }
  manualEntry: boolean
}

export interface HealthMetrics {
  date: string
  averageHeartRate?: number
  restingHeartRate?: number
  activeHeartRate?: number
  hrvScore?: number
  stepsGoalAchieved?: boolean
  sleepEfficiency?: number
  recoveryScore?: number // 0-100
  readinessScore?: number // 0-100 (combination of metrics)
}

export interface ProductivityCorrelation {
  date: string
  biometric: BiometricData
  productivity: {
    tasksCompleted: number
    focusTime: number
    qualityScore: number
    efficiencyScore: number
    creativityScore: number
  }
  correlations: {
    sleepVsProductivity: number
    heartRateVsFocus: number
    stepsVsEnergy: number
    moodVsCreativity: number
    overallCorrelation: number
  }
}

export interface BiometricInsight {
  id: string
  type: 'pattern' | 'recommendation' | 'alert' | 'trend' | 'optimization'
  title: string
  description: string
  insight: string
  actionable: boolean
  recommendations: string[]
  priority: 'low' | 'medium' | 'high' | 'urgent'
  confidence: number
  dataPoints: string[]
  createdAt: Date
}

export interface OptimalConditions {
  heartRateRange: { min: number; max: number }
  optimalSleepDuration: number
  optimalSteps: number
  bestWorkingHours: number[]
  optimalEnvironment: {
    temperature?: number
    humidity?: number
    lightLevel?: string
  }
}

class BiometricTrackingService {
  private biometricData: BiometricData[] = []
  private healthMetrics: Map<string, HealthMetrics> = new Map()
  private correlations: ProductivityCorrelation[] = []
  private insights: BiometricInsight[] = []
  private optimalConditions: OptimalConditions | null = null

  // Device integration support
  private isWatchConnected: boolean = false
  private isFitnessTrackerConnected: boolean = false
  private webSensorsSupported: boolean = false

  constructor() {
    this.checkDeviceSupport()
    this.loadData()
    this.requestSensorPermissions()
  }

  private checkDeviceSupport(): void {
    // Check for Web Sensors API support
    this.webSensorsSupported = 'Accelerometer' in window || 'HeartRateSensor' in window

    // Check for potential fitness device connections
    this.checkFitnessDeviceSupport()
  }

  private async checkFitnessDeviceSupport(): Promise<void> {
    // Check for Web Bluetooth API for fitness devices
    if ('bluetooth' in navigator) {
      try {
        // This is just a check, not actually connecting
        console.log('Bluetooth API available for fitness device integration')
      } catch (error) {
        console.log('Bluetooth API not available')
      }
    }

    // Check for Health API integration (future implementation)
    if ('health' in navigator) {
      console.log('Health API available')
    }
  }

  private async requestSensorPermissions(): Promise<void> {
    try {
      // Request motion sensors permission
      if ('DeviceMotionEvent' in window && typeof (DeviceMotionEvent as any).requestPermission === 'function') {
        const permission = await (DeviceMotionEvent as any).requestPermission()
        if (permission === 'granted') {
          this.initializeMotionTracking()
        }
      }

      // Request location permission for environmental correlation
      if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(
          () => console.log('Location permission granted'),
          () => console.log('Location permission denied')
        )
      }
    } catch (error) {
      console.error('Permission request failed:', error)
    }
  }

  private initializeMotionTracking(): void {
    if (window.DeviceMotionEvent) {
      window.addEventListener('devicemotion', (event) => {
        // Basic activity detection from accelerometer
        const acceleration = event.acceleration
        if (acceleration) {
          const totalAcceleration = Math.sqrt(
            Math.pow(acceleration.x || 0, 2) +
            Math.pow(acceleration.y || 0, 2) +
            Math.pow(acceleration.z || 0, 2)
          )

          // Simple step detection (basic implementation)
          if (totalAcceleration > 2) {
            this.incrementStepCount()
          }
        }
      })
    }
  }

  private incrementStepCount(): void {
    const today = new Date().toISOString().split('T')[0]
    const todayData = this.biometricData.find(d => d.date === today)

    if (todayData) {
      todayData.stepCount = (todayData.stepCount || 0) + 1
    } else {
      this.recordBiometricData({
        stepCount: 1,
        manualEntry: false
      })
    }
  }

  // Data Recording
  recordBiometricData(data: Partial<Omit<BiometricData, 'id' | 'timestamp' | 'date'>>): BiometricData {
    const today = new Date().toISOString().split('T')[0]
    const existingData = this.biometricData.find(d => d.date === today)

    if (existingData) {
      // Update existing data
      Object.assign(existingData, data)
      existingData.timestamp = Date.now()
      this.saveData()
      return existingData
    } else {
      // Create new entry
      const newData: BiometricData = {
        id: `biometric-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        timestamp: Date.now(),
        date: today,
        manualEntry: data.manualEntry ?? true,
        ...data
      }

      this.biometricData.push(newData)
      this.calculateHealthMetrics(today)
      this.generateInsights()
      this.saveData()
      return newData
    }
  }

  // Automated Data Collection
  async collectEnvironmentalData(): Promise<Partial<BiometricData>> {
    const environmentalData: Partial<BiometricData> = {}

    // Location data
    if (navigator.geolocation) {
      try {
        const position = await new Promise<GeolocationPosition>((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            timeout: 10000,
            maximumAge: 300000 // 5 minutes
          })
        })

        environmentalData.location = {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude
        }

        // Get weather data (would need API integration)
        const weather = await this.getWeatherData(position.coords.latitude, position.coords.longitude)
        if (weather) {
          environmentalData.weather = weather
        }
      } catch (error) {
        console.error('Failed to get location:', error)
      }
    }

    // Screen time tracking (using Page Visibility API)
    environmentalData.screenTime = this.calculateDailyScreenTime()

    return environmentalData
  }

  private async getWeatherData(lat: number, lon: number): Promise<BiometricData['weather'] | null> {
    // This would integrate with a weather API
    // For demo purposes, returning mock data
    return {
      temperature: 22 + Math.random() * 10, // 22-32Â°C
      humidity: 40 + Math.random() * 40, // 40-80%
      condition: ['sunny', 'cloudy', 'rainy'][Math.floor(Math.random() * 3)]
    }
  }

  private calculateDailyScreenTime(): number {
    // Track screen time using Page Visibility API
    const screenTimeKey = `screen-time-${new Date().toISOString().split('T')[0]}`
    const stored = localStorage.getItem(screenTimeKey)

    if (stored) {
      const data = JSON.parse(stored)
      return data.totalTime / (1000 * 60 * 60) // Convert to hours
    }

    return 0
  }

  // Health Metrics Calculation
  private calculateHealthMetrics(date: string): void {
    const dayData = this.biometricData.filter(d => d.date === date)
    if (dayData.length === 0) return

    const latestData = dayData[dayData.length - 1]
    const heartRates = dayData.filter(d => d.heartRate).map(d => d.heartRate!)

    const metrics: HealthMetrics = {
      date,
      averageHeartRate: heartRates.length > 0
        ? heartRates.reduce((sum, hr) => sum + hr, 0) / heartRates.length
        : undefined,
      restingHeartRate: heartRates.length > 0 ? Math.min(...heartRates) : undefined,
      activeHeartRate: heartRates.length > 0 ? Math.max(...heartRates) : undefined,
      hrvScore: latestData.heartRateVariability,
      stepsGoalAchieved: (latestData.stepCount || 0) >= 10000,
      sleepEfficiency: latestData.sleepQuality,
      recoveryScore: this.calculateRecoveryScore(latestData),
      readinessScore: this.calculateReadinessScore(latestData)
    }

    this.healthMetrics.set(date, metrics)
  }

  private calculateRecoveryScore(data: BiometricData): number {
    let score = 50 // Base score

    // Sleep quality impact (30% weight)
    if (data.sleepQuality !== undefined) {
      score += (data.sleepQuality - 50) * 0.3
    }

    // Sleep duration impact (20% weight)
    if (data.sleepDuration !== undefined) {
      const optimalSleep = 8
      const sleepDifference = Math.abs(data.sleepDuration - optimalSleep)
      score += Math.max(0, (2 - sleepDifference) * 10) * 0.2
    }

    // HRV impact (25% weight)
    if (data.heartRateVariability !== undefined) {
      // Higher HRV is generally better (normalized to 0-100)
      const normalizedHRV = Math.min(100, data.heartRateVariability * 2)
      score += (normalizedHRV - 50) * 0.25
    }

    // Stress level impact (25% weight)
    if (data.stressLevel !== undefined) {
      score += (50 - data.stressLevel) * 0.25
    }

    return Math.max(0, Math.min(100, score))
  }

  private calculateReadinessScore(data: BiometricData): number {
    let score = 50 // Base score

    // Recovery score impact
    const recoveryScore = this.calculateRecoveryScore(data)
    score += (recoveryScore - 50) * 0.4

    // Energy level impact
    if (data.energyLevel !== undefined) {
      score += (data.energyLevel - 50) * 0.3
    }

    // Mood impact
    if (data.mood !== undefined) {
      score += (data.mood - 50) * 0.2
    }

    // Focus level impact
    if (data.focusLevel !== undefined) {
      score += (data.focusLevel - 50) * 0.1
    }

    return Math.max(0, Math.min(100, score))
  }

  // Productivity Correlation Analysis
  analyzeProductivityCorrelation(productivityData: any[]): void {
    this.correlations = []

    productivityData.forEach(prodData => {
      const biometricData = this.biometricData.find(b => b.date === prodData.date)
      if (!biometricData) return

      const correlation: ProductivityCorrelation = {
        date: prodData.date,
        biometric: biometricData,
        productivity: prodData.productivity,
        correlations: this.calculateCorrelations(biometricData, prodData.productivity)
      }

      this.correlations.push(correlation)
    })

    this.generateProductivityInsights()
  }

  private generateProductivityInsights() {
    // Generate insights based on current data
    const recentData = this.data.slice(-7); // Last 7 entries
    if (recentData.length === 0) return;

    const avgStress = this.average(recentData.map(d => d.stressLevel).filter((val): val is number => typeof val === 'number'));
    const avgEnergy = this.average(recentData.map(d => d.energyLevel).filter((val): val is number => typeof val === 'number'));
    const avgSleep = this.average(recentData.map(d => d.sleepQuality).filter((val): val is number => typeof val === 'number'));

    // Generate insights based on patterns
    if (avgStress > 70) {
      console.log('High stress levels detected - consider stress management techniques');
    }
    if (avgEnergy < 30) {
      console.log('Low energy levels detected - consider improving sleep or nutrition');
    }
    if (avgSleep < 50) {
      console.log('Poor sleep quality detected - consider sleep hygiene improvements');
    }
  }

  private calculateCorrelations(biometric: BiometricData, productivity: any) {
    return {
      sleepVsProductivity: this.correlateValues(
        biometric.sleepQuality || 50,
        productivity.efficiencyScore * 10
      ),
      heartRateVsFocus: this.correlateValues(
        this.normalizeHeartRate(biometric.heartRate || 70),
        productivity.focusTime / 8 * 100 // Normalize to 8 hours
      ),
      stepsVsEnergy: this.correlateValues(
        Math.min(100, (biometric.stepCount || 0) / 100),
        biometric.energyLevel || 50
      ),
      moodVsCreativity: this.correlateValues(
        biometric.mood || 50,
        productivity.creativityScore * 10
      ),
      overallCorrelation: 0 // Will be calculated
    }
  }

  private correlateValues(x: number, y: number): number {
    // Simple correlation calculation (-1 to 1)
    const normalizedX = x / 100
    const normalizedY = y / 100

    // Pearson-like correlation
    return 1 - Math.abs(normalizedX - normalizedY)
  }

  private normalizeHeartRate(hr: number): number {
    // Normalize heart rate to 0-100 scale (assuming 60-100 is optimal range)
    const optimalMin = 60
    const optimalMax = 100

    if (hr < optimalMin) return 100 - ((optimalMin - hr) / optimalMin) * 100
    if (hr > optimalMax) return 100 - ((hr - optimalMax) / optimalMax) * 100

    return 100 // Optimal range
  }

  // Insights Generation
  generateInsights(): void {
    this.insights = []

    this.analyzeSleepPatterns()
    this.analyzeActivityPatterns()
    this.analyzeStressPatterns()
    this.analyzeOptimalConditions()
    this.generateRecommendations()

    this.saveData()
  }

  private analyzeSleepPatterns(): void {
    const recentData = this.getRecentData(14)
    const sleepData = recentData.filter(d => d.sleepDuration !== undefined)

    if (sleepData.length < 7) return

    const avgSleepDuration = sleepData.reduce((sum, d) => sum + (d.sleepDuration || 0), 0) / sleepData.length
    const avgSleepQuality = sleepData.reduce((sum, d) => sum + (d.sleepQuality || 0), 0) / sleepData.length

    if (avgSleepDuration < 7) {
      this.insights.push({
        id: `sleep-duration-${Date.now()}`,
        type: 'alert',
        title: 'ìë©´ ë¶ì¡± í¨í´',
        description: `íê·  ìë©´ìê°ì´ ${avgSleepDuration.toFixed(1)}ìê°ì¼ë¡ ë¶ì¡±í©ëë¤.`,
        insight: 'ì¶©ë¶í ìë©´ì ìì°ì±ê³¼ ê±´ê°ì ë§¤ì° ì¤ìí©ëë¤.',
        actionable: true,
        recommendations: [
          'ë§¤ì¼ ê°ì ìê°ì ì ìë¦¬ì ë¤ê¸°',
          'ì·¨ì¹¨ 1ìê° ì  ì ìê¸°ê¸° ì¬ì© ì¤ë¨',
          'ìë©´ íê²½ ê°ì  (ì¨ë, ì¡°ëª, ìì)',
          'ì¹´íì¸ ì­ì·¨ ìê° ì¡°ì '
        ],
        priority: 'high',
        confidence: 0.9,
        dataPoints: [`íê·  ìë©´ìê°: ${avgSleepDuration.toFixed(1)}ìê°`],
        createdAt: new Date()
      })
    }

    if (avgSleepQuality < 60) {
      this.insights.push({
        id: `sleep-quality-${Date.now()}`,
        type: 'recommendation',
        title: 'ìë©´ ì§ ê°ì  íì',
        description: `íê·  ìë©´ ì§ ì ìê° ${avgSleepQuality.toFixed(0)}ì ì¼ë¡ ë®ìµëë¤.`,
        insight: 'ìë©´ì ì§ì´ ë®ì¼ë©´ ë¤ì ë  ì§ì¤ë ¥ê³¼ ìëì§ ìì¤ì´ ì íë©ëë¤.',
        actionable: true,
        recommendations: [
          'ê·ì¹ì ì¸ ì´ë (ë¨, ì·¨ì¹¨ 4ìê° ì ê¹ì§)',
          'ì¤í¸ë ì¤ ê´ë¦¬ ê¸°ë² ì°ìµ',
          'ìë©´ ì¶ì ì íµí í¨í´ íì',
          'ì¹¨ì¤ íê²½ ìµì í'
        ],
        priority: 'medium',
        confidence: 0.8,
        dataPoints: [`íê·  ìë©´ ì§: ${avgSleepQuality.toFixed(0)}ì `],
        createdAt: new Date()
      })
    }
  }

  private analyzeActivityPatterns(): void {
    const recentData = this.getRecentData(7)
    const activeData = recentData.filter(d => d.stepCount !== undefined)

    if (activeData.length < 5) return

    const avgSteps = activeData.reduce((sum, d) => sum + (d.stepCount || 0), 0) / activeData.length
    const activeMinutes = activeData.reduce((sum, d) => {
      return sum + (d.physicalActivity?.reduce((acc, act) => acc + act.duration, 0) || 0)
    }, 0) / activeData.length

    if (avgSteps < 8000) {
      this.insights.push({
        id: `activity-low-${Date.now()}`,
        type: 'recommendation',
        title: 'íëë ë¶ì¡±',
        description: `ì¼íê·  ${Math.round(avgSteps)}ë³´ë¡ ê¶ì¥ëì ë¯¸ë¬ìëë¤.`,
        insight: 'ì ì í ì ì²´ íëì ìëì§ ìì¤ê³¼ ì§ì¤ë ¥ í¥ìì ëìì´ ë©ëë¤.',
        actionable: true,
        recommendations: [
          'íë£¨ 10,000ë³´ ëª©í ì¤ì ',
          'ê³ë¨ ì´ì©íê¸°',
          'ì ì¬ìê° ì°ì±',
          'ìì ì¼íë ìê° ëë¦¬ê¸°',
          'ì§§ì ì´ë ë£¨í´ ì¶ê°'
        ],
        priority: 'medium',
        confidence: 0.7,
        dataPoints: [`íê·  ê±¸ìì: ${Math.round(avgSteps)}ë³´`],
        createdAt: new Date()
      })
    }

    if (activeMinutes < 30) {
      this.insights.push({
        id: `exercise-low-${Date.now()}`,
        type: 'recommendation',
        title: 'ì´ë ìê° ë¶ì¡±',
        description: `ì¼íê·  ì´ëìê°ì´ ${Math.round(activeMinutes)}ë¶ì¼ë¡ ë¶ì¡±í©ëë¤.`,
        insight: 'ê·ì¹ì ì¸ ì´ëì ì¤í¸ë ì¤ í´ìì ìì°ì± í¥ìì í¨ê³¼ì ìëë¤.',
        actionable: true,
        recommendations: [
          'ì£¼ 3í ì´ì 30ë¶ ì´ë',
          'ìë¬´ ì¤ ì¤í¸ë ì¹­ ìê°',
          'ê³ë¨ ì¤ë¥´ê¸°, ë¹ ë¥¸ ê±·ê¸° ë± ê°ë¨í ì´ë',
          'ì´ë ì¤ì¼ì¤ ì íê¸°'
        ],
        priority: 'medium',
        confidence: 0.8,
        dataPoints: [`íê·  ì´ëìê°: ${Math.round(activeMinutes)}ë¶`],
        createdAt: new Date()
      })
    }
  }

  private analyzeStressPatterns(): void {
    const recentData = this.getRecentData(14)
    const stressData = recentData.filter(d => d.stressLevel !== undefined)

    if (stressData.length < 7) return

    const avgStress = stressData.reduce((sum, d) => sum + (d.stressLevel || 0), 0) / stressData.length
    const highStressDays = stressData.filter(d => (d.stressLevel || 0) > 70).length

    if (avgStress > 60) {
      this.insights.push({
        id: `stress-high-${Date.now()}`,
        type: 'alert',
        title: 'ì¤í¸ë ì¤ ìì¤ ëì',
        description: `íê·  ì¤í¸ë ì¤ ìì¤ì´ ${avgStress.toFixed(0)}ì ì¼ë¡ ëìµëë¤.`,
        insight: 'ì§ìì ì¸ ê³ ì¤í¸ë ì¤ë ê±´ê°ê³¼ ìì°ì±ì ë¶ì ì  ìí¥ì ë¯¸ì¹©ëë¤.',
        actionable: true,
        recommendations: [
          'ëªìì´ë ì¬í¸í¡ ì°ìµ',
          'ìë¬´ ì°ì ìì ì¬ì ë¦¬',
          'ì¶©ë¶í í´ì ìê° íë³´',
          'ì¤í¸ë ì¤ ìì¸ íì ë° ê´ë¦¬',
          'ì ë¬¸ê° ìë´ ê³ ë ¤'
        ],
        priority: 'high',
        confidence: 0.85,
        dataPoints: [
          `íê·  ì¤í¸ë ì¤: ${avgStress.toFixed(0)}ì `,
          `ê³ ì¤í¸ë ì¤ ì¼ì: ${highStressDays}ì¼`
        ],
        createdAt: new Date()
      })
    }

    if (highStressDays > stressData.length * 0.5) {
      this.insights.push({
        id: `stress-frequent-${Date.now()}`,
        type: 'pattern',
        title: 'ë¹ë²í ê³ ì¤í¸ë ì¤',
        description: `${highStressDays}ì¼ê° ëì ì¤í¸ë ì¤ë¥¼ ê²½ííìµëë¤.`,
        insight: 'ì¤í¸ë ì¤ ê´ë¦¬ ì ëµì´ íìí©ëë¤.',
        actionable: true,
        recommendations: [
          'ì¤í¸ë ì¤ ì¼ê¸° ìì±',
          'í¸ë¦¬ê±° ìì¸ ë¶ì',
          'ëì² ë°©ë² ê°ë°',
          'ìí í¨í´ ì¡°ì '
        ],
        priority: 'high',
        confidence: 0.8,
        dataPoints: [`ê³ ì¤í¸ë ì¤ ë¹ë: ${(highStressDays / stressData.length * 100).toFixed(0)}%`],
        createdAt: new Date()
      })
    }
  }

  private analyzeOptimalConditions(): void {
    if (this.correlations.length < 14) return

    const highProductivityDays = this.correlations.filter(c =>
      c.productivity.efficiencyScore > 7 && c.productivity.qualityScore > 7
    )

    if (highProductivityDays.length < 3) return

    // Analyze patterns in high productivity days
    const optimalSleep = highProductivityDays.reduce((sum, day) =>
      sum + (day.biometric.sleepDuration || 8), 0
    ) / highProductivityDays.length

    const optimalSteps = highProductivityDays.reduce((sum, day) =>
      sum + (day.biometric.stepCount || 0), 0
    ) / highProductivityDays.length

    this.optimalConditions = {
      heartRateRange: {
        min: 60,
        max: 90
      },
      optimalSleepDuration: optimalSleep,
      optimalSteps: optimalSteps,
      bestWorkingHours: [9, 10, 11, 14, 15, 16], // Would be analyzed from data
      optimalEnvironment: {
        temperature: 22,
        humidity: 50
      }
    }

    this.insights.push({
      id: `optimal-conditions-${Date.now()}`,
      type: 'optimization',
      title: 'ìµì  ìì°ì± ì¡°ê±´ ë°ê²¬',
      description: 'ëì ìì°ì±ì ë³´ì¸ ë ë¤ì ê³µíµ í¨í´ì ë°ê²¬íìµëë¤.',
      insight: `ìµì  ìë©´ìê°: ${optimalSleep.toFixed(1)}ìê°, ìµì  íëë: ${Math.round(optimalSteps)}ë³´`,
      actionable: true,
      recommendations: [
        `${optimalSleep.toFixed(1)}ìê° ìë©´ ëª©í`,
        `ì¼ì¼ ${Math.round(optimalSteps)}ë³´ íë ëª©í`,
        '9-11ì, 14-16ì ì§ì¤ ìë¬´ ìê° íì©',
        'ìµì  íê²½ ì¡°ê±´ ì ì§'
      ],
      priority: 'medium',
      confidence: 0.75,
      dataPoints: [
        `ë¶ì ê¸°ë° ì¼ì: ${highProductivityDays.length}ì¼`,
        `ìµì  ìë©´: ${optimalSleep.toFixed(1)}ìê°`,
        `ìµì  íë: ${Math.round(optimalSteps)}ë³´`
      ],
      createdAt: new Date()
    })
  }

  private generateRecommendations(): void {
    const recentData = this.getRecentData(7)
    if (recentData.length === 0) return

    // Hydration recommendations
    const avgHydration = recentData
      .filter(d => d.hydrationLevel !== undefined)
      .reduce((sum, d) => sum + (d.hydrationLevel || 0), 0) / recentData.length

    if (avgHydration < 2000) { // Less than 2L per day
      this.insights.push({
        id: `hydration-${Date.now()}`,
        type: 'recommendation',
        title: 'ìë¶ ì­ì·¨ ë¶ì¡±',
        description: `ì¼íê·  ìë¶ ì­ì·¨ëì´ ${Math.round(avgHydration)}mlë¡ ë¶ì¡±í©ëë¤.`,
        insight: 'ì ì í ìë¶ ì­ì·¨ë ì§ì¤ë ¥ê³¼ ìëì§ ì ì§ì ì¤ìí©ëë¤.',
        actionable: true,
        recommendations: [
          'íë£¨ 2-3L ë¬¼ ì­ì·¨ ëª©í',
          'ì¼ì  ê°ê²©ì¼ë¡ ë¬¼ ë§ìê¸° ìë',
          'ë¬¼ë³ í­ì ì¤ë¹íê¸°',
          'ì¹´íì¸ ìë£ ì¤ì´ê¸°'
        ],
        priority: 'low',
        confidence: 0.6,
        dataPoints: [`íê·  ìë¶ ì­ì·¨: ${Math.round(avgHydration)}ml`],
        createdAt: new Date()
      })
    }

    // Screen time recommendations
    const avgScreenTime = recentData
      .filter(d => d.screenTime !== undefined)
      .reduce((sum, d) => sum + (d.screenTime || 0), 0) / recentData.length

    if (avgScreenTime > 8) { // More than 8 hours per day
      this.insights.push({
        id: `screen-time-${Date.now()}`,
        type: 'recommendation',
        title: 'ê³¼ëí ì¤í¬ë¦° ìê°',
        description: `ì¼íê·  ì¤í¬ë¦° ìê°ì´ ${avgScreenTime.toFixed(1)}ìê°ìëë¤.`,
        insight: 'ê³¼ëí ì¤í¬ë¦° ìê°ì ëì í¼ë¡ì ìë©´ ì§ì ìí¥ì ì¤ ì ììµëë¤.',
        actionable: true,
        recommendations: [
          '20-20-20 ê·ì¹ ì ì© (20ë¶ë§ë¤ 20ì´ê° 20í¼í¸ ê±°ë¦¬ ë°ë¼ë³´ê¸°)',
          'ì·¨ì¹¨ 1ìê° ì  ì¤í¬ë¦° ì°¨ë¨',
          'ë¸ë£¨ë¼ì´í¸ íí° ì¬ì©',
          'ì ê¸°ì ì¸ ë í´ì'
        ],
        priority: 'medium',
        confidence: 0.7,
        dataPoints: [`íê·  ì¤í¬ë¦° ìê°: ${avgScreenTime.toFixed(1)}ìê°`],
        createdAt: new Date()
      })
    }
  }

  // Data Access Methods
  private getRecentData(days: number): BiometricData[] {
    const cutoff = Date.now() - days * 24 * 60 * 60 * 1000
    return this.biometricData.filter(d => d.timestamp > cutoff)
  }

  getBiometricData(days: number = 30): BiometricData[] {
    return this.getRecentData(days)
  }

  getHealthMetrics(days: number = 30): HealthMetrics[] {
    const cutoffDate = new Date()
    cutoffDate.setDate(cutoffDate.getDate() - days)

    return Array.from(this.healthMetrics.values())
      .filter(m => new Date(m.date) >= cutoffDate)
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
  }

  getInsights(): BiometricInsight[] {
    return this.insights.sort((a, b) => {
      const priorityOrder = { urgent: 4, high: 3, medium: 2, low: 1 }
      return priorityOrder[b.priority] - priorityOrder[a.priority]
    })
  }

  getCorrelations(): ProductivityCorrelation[] {
    return this.correlations
  }

  getOptimalConditions(): OptimalConditions | null {
    return this.optimalConditions
  }

  // Dashboard Data
  getDashboardData() {
    const recentData = this.getRecentData(7)
    const todayData = this.getRecentData(1)[0]

    return {
      today: todayData || null,
      weeklyAverage: this.calculateWeeklyAverages(recentData),
      insights: this.getInsights().slice(0, 5),
      correlations: this.correlations.slice(-7),
      healthMetrics: Array.from(this.healthMetrics.values()).slice(-7),
      optimalConditions: this.optimalConditions,
      trends: this.calculateTrends(recentData)
    }
  }

  private calculateWeeklyAverages(data: BiometricData[]) {
    if (data.length === 0) return null

    return {
      heartRate: this.average(data.map(d => d.heartRate).filter((val): val is number => typeof val === 'number')),
      steps: this.average(data.map(d => d.stepCount).filter((val): val is number => typeof val === 'number')),
      sleep: this.average(data.map(d => d.sleepDuration).filter((val): val is number => typeof val === 'number')),
      sleepQuality: this.average(data.map(d => d.sleepQuality).filter((val): val is number => typeof val === 'number')),
      stress: this.average(data.map(d => d.stressLevel).filter((val): val is number => typeof val === 'number')),
      energy: this.average(data.map(d => d.energyLevel).filter((val): val is number => typeof val === 'number')),
      mood: this.average(data.map(d => d.mood).filter((val): val is number => typeof val === 'number'))
    }
  }

  private calculateTrends(data: BiometricData[]) {
    // Simple trend calculation (positive/negative/stable)
    const first = data.slice(0, Math.floor(data.length / 2))
    const second = data.slice(Math.floor(data.length / 2))

    const firstAvg = this.calculateWeeklyAverages(first)
    const secondAvg = this.calculateWeeklyAverages(second)

    if (!firstAvg || !secondAvg) return null

    return {
      sleep: this.getTrend(firstAvg.sleep, secondAvg.sleep),
      energy: this.getTrend(firstAvg.energy, secondAvg.energy),
      stress: this.getTrend(firstAvg.stress, secondAvg.stress, true), // Lower is better
      activity: this.getTrend(firstAvg.steps, secondAvg.steps)
    }
  }

  private getTrend(oldVal: number, newVal: number, reverse: boolean = false): 'improving' | 'declining' | 'stable' {
    if (!oldVal || !newVal) return 'stable'

    const change = (newVal - oldVal) / oldVal
    const threshold = 0.1 // 10% change threshold

    if (Math.abs(change) < threshold) return 'stable'

    const improving = reverse ? change < 0 : change > 0
    return improving ? 'improving' : 'declining'
  }

  private average(values: number[]): number {
    return values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : 0
  }

  // Device Integration
  async connectFitnessDevice(): Promise<boolean> {
    if (!('bluetooth' in navigator)) {
      throw new Error('Bluetooth not supported')
    }

    try {
      // Request Bluetooth device with heart rate service
      const device = await (navigator.bluetooth as any).requestDevice({
        filters: [{ services: ['heart_rate'] }],
        optionalServices: ['battery_service']
      })

      const server = await device.gatt.connect()
      console.log('Connected to fitness device:', device.name)

      this.isFitnessTrackerConnected = true
      return true
    } catch (error) {
      console.error('Failed to connect to fitness device:', error)
      return false
    }
  }

  // Data Export
  exportData() {
    return {
      biometricData: this.biometricData,
      healthMetrics: Array.from(this.healthMetrics.entries()),
      correlations: this.correlations,
      insights: this.insights,
      optimalConditions: this.optimalConditions
    }
  }

  // Data Persistence
  private saveData(): void {
    try {
      const data = {
        biometricData: this.biometricData,
        healthMetrics: Array.from(this.healthMetrics.entries()),
        correlations: this.correlations,
        insights: this.insights,
        optimalConditions: this.optimalConditions
      }
      localStorage.setItem('jihyung-biometric-tracking', JSON.stringify(data))
    } catch (error) {
      console.error('ìì²´ ë°ì´í° ì ì¥ ì¤í¨:', error)
    }
  }

  private loadData(): void {
    try {
      const saved = localStorage.getItem('jihyung-biometric-tracking')
      if (!saved) return

      const data = JSON.parse(saved)

      this.biometricData = (data.biometricData || []).map((item: any) => ({
        ...item,
        timestamp: typeof item.timestamp === 'string' ? new Date(item.timestamp).getTime() : item.timestamp
      }))

      this.healthMetrics = new Map(data.healthMetrics || [])
      this.correlations = data.correlations || []

      this.insights = (data.insights || []).map((insight: any) => ({
        ...insight,
        createdAt: new Date(insight.createdAt)
      }))

      this.optimalConditions = data.optimalConditions || null

    } catch (error) {
      console.error('ìì²´ ë°ì´í° ë¡ë ì¤í¨:', error)
    }
  }
}

// Export singleton instance
export const biometricTrackingService = new BiometricTrackingService()

export default biometricTrackingService